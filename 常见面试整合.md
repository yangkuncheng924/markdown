# 一、JAVA基础

## 1.JDK 和JRE有什么区别？

- jdk ，java开发工具包，提供了java的开发环境和运行环境

- jre， java运行环境 为java的运行提供了所需环境

## 2. == 和 equals区别是什么？

- ==解读
  
  - 基本类型 比较的值是否相同
  - 引用类型 比较的是引用是否相同
- equals解读

  - quals是在类型值比较

  - equals本质上就是==，只不过String和Integer等重写了equals方法，把它变成了**值比较**

    

- == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。

  

## 3.final在java中有什么作用？

- final修饰的类叫做最终类，该类不能被继承
- final修饰的方法不能被重写
- final修饰的变量叫常量 ，常量必须初始化，初始化就不能改变值

## 4.String类型属于基本类型吗？

- String类型不是基本类型，String属于对象，常见的基本类型有 int，fload，double，bool，char，short，long

## 5.Stringbuffer，Stringbuilder，String区别

- Stringbuffer，Stringbuilder，String

- String和Stringbuffer、Stringbuilder的区别在于String是不可变对象，每次操作都会产生新的对象，然后指针指向新的String对象，而Stringbuffer，Stringbuilder可以在原有对象进行操作，所以在经常改变字符串内容，最好不要使用String

- Stringbuffer、Stringbuider的区别是Stringbuffer是线程安全的，Stringbuilder线程是不安全的，但是Stringbuider运行效率要高于Stringbuffer，所以在单线程这里推荐使用Stringbuilder，多线程环境下推荐使用Stringbuffer

## 6.String str = “i” 和 String str = new String（“i“）一样吗？

- 不一样，是内存分配的不一样，第一种是分配到常量池中，而new的是要被分配到堆中

## 7.如何将字符串进行反转？

- 使用StringBuilde或者StringBuffer中的reverse()方法

  ~~~java
  StringBuffer x = new StringBuffer("abcdefg");
  System.out.println("x = " + x);
  x.reverse();
  System.out.println("x = " + x);
  ~~~

## 8.String中的常用方法有哪些？

- indexof() : 返回值指定索引
- charAt() :返回指定字符串的索引处
- length() : 返回字符串长度
- equals()：字符串比较
- substring() :截取字符串

## 9.抽象类必须要有抽象方法吗？

- 不需要 抽象类不一定得有抽象方法

## 10.普通类和抽象类有什么区别？

- 普通类不能包含抽象方法，抽象类可以包含抽象方法
- 抽象类不能直接实例化，普通类可以直接实例化

## 11.抽象类可以用final修饰吗？

- 不能，定义抽象类就是让其它类继承，如果final修饰了就不能继承，会出现矛盾，编译器会报错

## 12接口和抽象类有什么区别？

- 实现：抽象类的子类用extends来继承，接口必须要用inmplements来实现接口
- 构造函数，抽象类可以有构造函数，接口不能
- main方法，抽象类可以有main方法，接口不行
- 实现数量，类可以实现多个接口，但是只能继承一个抽象类
- 修饰符：接口默认使用public，抽象类可以使用任何修饰符

## 15.java中io分为几种？

- 按功能来分类 输入流(input) 输出流(output)

- 按类型来分： 字节流和字符流
- 字节流和字符流的区别是：字节流是8位传输以单位输入输出数据，字符流是按照16位传输字符为单位输入输出数据

## 16.BIO、NIO、AIO有什么区别

- BIO、同步阻塞IO，就是我们平常用的传统IO，它的特点就是简单使用方便，并发处理能力低
- NIO、New IO同步非阻塞IO，是传统的IO升级，客户端和服务端通过通道通讯，实现乐多路复用
- AIO、实现乐异步非阻塞IO，异步IO的操作基于时间和回调机制

## 17.Files的常用方法有哪些？

- File.write（） 写入
- File.Read（） 读取
- File.size ()  查看文件数量
- File.move 移动文件
- File.copy 赋值文件
- File.delete(): 删除文件

## 18.static关键字

- static 关键字可以用来修饰：属性、方法、内部类、代码块；
- static 修饰的资源属于**类级别**，是全体对象实例共享的资源；
- 使用 static 修饰的属性，静态属性是在类的加载期间初始化的，使用**类名.属性**访问

# 二、容器

## 1.常用容器有哪些？

- Hashset、List、ArryLis、Haspmap、map、vetror、Set、Hashmap、Treemap

![image-20200705202135425](C:\Users\15371\AppData\Roaming\Typora\typora-user-images\image-20200705202135425.png)



## 2.List、Set、Map之间有什么区别？

![image-20200705202357419](C:\Users\15371\AppData\Roaming\Typora\typora-user-images\image-20200705202357419.png)

## 3.HashMap和Hashtable有什么区别？

- HashMap去掉了Hashtable的contains方法，但是加上containsValue()和containsKey()方法
- HashTable是同步，HashMap是非同步，效率要比hashtable要高

- hashMap允许空键值，hashtable不允许

## 4.如果决定使用HashMap还是TreeMap？

- 对于插入、删除定位元素使用HashMap对于查找有序的key使用TreeMap，基于你的collection的大小，也许向HashMap添加元素更快

## 5.说一下HashMap的底层实现原理？

- HashMap概述、HashMap是基于哈希表的Map接口的非同步实现，此实现提供了所有可选的映射操作，并且必须使用null值和null键，此类不保证映射顺序，特别是它不保证该顺序恒久衰变

- HashMap的数据结构，在java遇见中，最基本的结构就是两种，数组加引用指针，所有数据结构底层都可以用这两个基本结构来构造，HashMap也不列外，HashMap底层实现上是一个数组加链表 的结合体
- 当我们往HashMap放入元素，首先根据key的hashcode重新计算hash值，根据hash值得到这个元素在数组中的下标，如果该数组已经存放了其它元素，那么在这个位置上的元素将链表形式存放，新加入的放在链表头，最先加入的放在链表尾，如果数组中该位置没有元素就直接将元素放在该位置上

注意：Jdk1.8中对HashMap的实现做了优化，当链表中的节点数据超过了八个以后，该链表会转换为红黑树来提高查询效率，从原来的O在（n）到O(logn)

## 6.说一下HashSet的实现原理

- HashSet的底层是由HashMap来实现
- HashSet的值存放于HashMap的key上
- HashMap的value统一为PRESENT

## 7.ArrayList和LinkedList的区别是什么?

最明显的区别是ArrayList底层的数据结构是数组，支持随机访问，而LinkedList底层数据结构是双向循环链表，不支持随机访问，使用下标访问一个元素，ArrayList的时间复杂度是O(1)，而LinkedList是O(n)

## 8.如何实现数组和List之间的转换？

- List转换数组使用toArray方法
- 数组转换为List：调用Array的asList方法

## 9.ArrayList和vector的区别是什么？

- verctor是同步的，而ArrayList不是，然而，如果你寻求在迭代的时候对列表进行变更
- ArrayList比Vector，因为有同步，不会过载
- ArrayList更加通用，因为我们可以使用Collection工具类轻易获取同步列表和只读列表

## 10.Array和ArrayList有什么区别？

- Array可以容纳基本类型和对象，ArrayList只能容纳对象
- Array是指定大小，而ArrayList大小是动态
- Array没有提供ArrayList那么多功能，比如addAll，removeAll和ieerator等

## 11.在Queue中poll（）和remove()有什么区别？

- poll和remove()都是从队列中取出元素，但是poll（）在获取元素失败会返回空，remove失败会抛出异常

## 12.那些集合类是线程安全的？

- vector 但是效率低
- statck 堆栈类，先进后出
- hashtable 就比hashmap多了个线程安全
- enumeration 枚举 相当于迭代器
- ConcurrentHashMap

## 13.迭代器Iterator是什么？

- 迭代器是一种设计模式 它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构，迭代器比较轻量级创建它的代价较少

## 14.Iterator的怎么使用？有什么特点？

- 使用方法ierator要求返回一个iterator，第一次调用iterator的next()方法，它返回序列的第一个元素.
- 使用next获取序列中的下一个元素
- 使用hasNext检查序列中是否还有元素
- 使用remove将迭代器新返回的元素删除
- Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。

## 15.Iterator和ListIterator有什么区别

- Iterator可以遍历Set和List集合，但是ListIterator只能用来遍历List
- Iterator对集合只能前向遍历，Listerator可以向前也可以先后
- ListIterator实现了ITerator接口，并包含其它元素，比如增加元素，替换元素，获取前一个和后一个元素的索引，等等

# 三、面向对象

## 1.面向对象的优点

易扩展，易维护，面向对象三大特征(封装，继承，多态)

### 1.1 封装

- 封装是把过程和数据包起来，对数据访问只能通过已定义的权限访问控制符规定范围
- 封装是面向编程的核心思想，指的就是讲描述某种实体的数据和基于这些数据集合到一起，就形成了封装体-
- 封装的思想保证了类内部数据结构的完成性，使用户无法轻易直接操作类的内部数据，这样降低了对内部数据影响，提高了程序的安全性和可维护性
- 封装的好处是：
  - 只能通过规定方法访问数据，隐藏类数据实现细节，方便修改实现，方便加入控制语句
- 封装的使用
  - 修改属性可见性，设置为private
  - 创建共有的get和set方法 用于属性的读写
  - 在git和set方法中加入属性控制语句 对属性值的合法性进行判断

### 1.2 继承

- 继承就是子类继承父类的特征和行为，似的子类对象(实例)具有父类的实例域和方法，或类从父类继承方法，使得子类具有父类相同的行为
- 特点：
  - 继承鼓励类的重用
  - 继承可以多层继承
  - 一个类只能继承一个父类
  - 父类中private不能被继承
  - 构造方法也不能被技能

- 使用
  - 继承的关键字  extends
  - super();　父类无参的构造方法
  - super(name);  父类有参的构造方法
  - super.name；访问父类属性
  - super.方法名，访问父类方法
- 方法的重写
  - 在子类中可以根据需要对父类中继承来的方法进行重新
  - 重新的方法和被重写方法必须具有相同方法名称，参数列表和返回值
  - 重写方法不能使用被重写方法更严格的权限访问

### 1.3多态

- 程序中的多态
  - 父类引用子类对象
  - 同一种事物，由于条件不同，产生的结果不同
  - 多态中一个应用类型，使用不同的实例而执行不同的操作
- **将父类对象应用于子类对象的特征就是面向对象编程中的多态出现**
- **多态指的就是在应用程序中出现的“重名”现象，多态性允许以统一的风格编写程序，以处理种类繁多的已存在的类及其相关类，这样既降低了维护难度，又节省时间**
- 使用多态实现思路
  - 编写父类
  - 编写子类，子类重写父类方法
  - 运行时，使用父类的类型，子类的对象
- 实现多态的三个必要条件
  -  继承
  -  重写
  - 父类引用子类对象
- 在java语言中，多态性主要表现在以下几个方面
  - 抽象类
  - 方法重写
  - 接口

## 2.如果声明一个静态块？静态块有什么好处？

- 在类中方法声明static关键字+代码块，对于一些必要初始化的代码，必须要在静态块里面，如果写在构造器里面，有多个构造器时候不一定执行初始化

## 3.接口与抽象类的区别？

- 抽象类必须要有abstract修饰，子类必须实现实现抽象类中方法，如果不能实现那么也得使用abstract修饰，抽象类默认权限修饰符是public，可以定义为proteced，如果定义为private 那么子类则无法继承。
- 接口的变量隐试的使用public static final修饰，并且需要给初始值，方法隐式的使用public absract修饰，接口的方法不能有实现，必须要有Implements实现这个类并且实现该方法否则报错。

- 区别：
  - 抽象类只能被继承一次 但是可以实现多个接口
  - 接口的抽象类必须实现其中所有的方法，抽象类如果有未实现的抽象方法，那么子类需要定义抽象类，抽象类可以有非抽象方法

## 4.类的组成和执行顺序？

- 组成 属性 方法 静态代码块，非静态代码块
- 执行顺序，父类、子类、静态块、静态字段、非静态块、非静态代码块、构造器、方法

## 5.重载与重写的区别？

- 重载是在一个类中，同名的方法它的参数顺序不一样，参数类型可以不一样，返回值可以不一样。
  - 重载是一个类中多态的表现
  - 重载要求命名相同参数不同
  - 重载的时候返回值类型可以不相同，无法以返回值作为区分重载的标准
- 重写从字面看就是重写一遍，就是在某个子类把父类本身有的方法进行重写，返回值方法名参数必须一致，重写方法一定不能抛出新的检查异常或者被重写方法申明更加宽泛的检查型异常

## 6、什么是装箱和拆箱

- 装箱就是讲基本类型转换为对象类型，拆箱就是讲对象类型转换为基本类型

## 7、请说说引用和对象？

- 对象和引用是分不开的，对象生成一个地址放在堆里面，引用是指向了这个地址，放在栈里面

## 8.什么是匿名类，有什么好处

匿名类没有名字的类，封装性较好，比较安全，用一次可以丢弃(jdk8可以不用匿名类，用lamdba表达式可以直接代替)

## 9.java和javac，javaaw各有什么作用？

- java	运行程序
- javac 编译文件到class文件
- javaw 不需要打开dos窗口即可运行

## 10.final特点

- 这个关键字是一个修饰符可以修饰类，方法，变量
- 被final修饰的类是一个最终类，不可以被继承
- 被final修饰的方法是最终方法，不可被覆盖
- 被final修饰的变量是一个常量，只能赋值一次
- 如果用在类上不能被继承，还有abstract和final不可以共存；用在方法上不能被重写；用在变量上不能被改变

## 11.final和static什么时候放在一起使用？

- final是最终的 被final修饰的变量只能赋值一次 如果加上static 就是在类运行这个变量就一直存在，而如果使用static他也虽然一直存在但是他可以被再次赋值。

## 12.基本类型和包装类的区别

- 基本类型放在栈里运行速度快，包装类型放在堆里面
- 包装类是对象，拥有方法，对调调用是引用对象地址
- 基本类型是值传递，包装类型是引用传递

# 四、多线程

## 1.并行和并发有什么区别？

- 并行是指两个或多个时间在同一时刻发生，而并发是指两个或多个事件在同一时间间隔发生
- 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件
- 在同一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务，如hadoop分布式集群
- 所以并发编程的目的是充分的利用处理器的每一个核，已达到最高的处理性能

## 2.线程和进程之间的区别？

简而言之，进程是程序运行资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程，进程在执行过程中拥有独立的内存单元，而多个线程的共享内存资源，减少切换次数，从而效率更高，线程是进程的一个实体，是cpu调度和分配的基本单位，是比程序更小的能独立运行的基本单位，同一个进程中的多个线程之间可以并发执行

## 3.守护线程是什么？

- 守护线程是个服务线程，准确的来说就是服务其它线程

## 4.创建线程分别有那几种方式？

- 继承Thread类创建线程类
  - 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
    创建Thread子类的实例，即创建了线程对象。
    调用线程对象的start()方法来启动该线程。
- 通过Runnable接口创建线程类
  - 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
    创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
    调用线程对象的start()方法来启动该线程。
- 通过Callable和Future创建线程
  -  创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
    创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
    使用FutureTask对象作为Thread对象的target创建并启动新线程。
    调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。		

## 5.说一下runnbale和callable有什么区别？

- Runnable的接口中的run方法是无返回值，它做的事情只是纯粹的执行了run方法中的代码而已
- callable接口中的call方法是有返回值的，是一个泛型。和Future、FutureTask配合可以用来获取异步执行的结果。

## 6.线程有哪些状态？

- 线程通常都有五种状态，	创建，就绪，运行，阻塞，死亡
  - 创建状态，在生成线程对象，并没有调用对象的start方法，这是线程处于创建状态
  - 就绪状态，当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态，在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态

## 7.sleep()和wait()有什么区别吗？

- sleep() 方法是线程类(Thred)的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间，因为sleep()是static静态方法，他不能改变对象的机制，当一个synchaonized块中调用了sleep()方法，线程虽然进入了休眠，但是对象的锁没有被释放，其它线程依然无法访问这个对象
- wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到了一个和该对象相关的等待池，同时释放对象的机锁，使得其它线程能够访问，可以通过notitfy，notifyAll方法来唤醒等待的线程

## 8.线程的run()和start()有什么区别

- 每个线程都是通过某个特定Thred对象所对应的方法run()来完成操作的，方法run称为线程体，通过调用Thred类的start方法来启动一个线程
- start方法来启动一个线程，真正实现了多线程运行，此时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码，这时此线程处于就绪状态，并没有运行。然后通过Thread类调用方法run()来完成其运行状态，这里方法run()称为线程体，它包含了要执行的这个线程内容，run方法运行结束，此线程终止。然后cpu在调度其它线程
- run方法是在本线程里的，只是线程里的一个函数，而不是多线程的。如果直接调用了run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待runi()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要用start()方法而不是run方法

## 9.创建线程池有那几种方式？

- .newFixedThreadPool（int nThreads）
  - 创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期错误而结束时，线程池会补充一个新的线程
- .newCachedThreadPool()
  - 创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制
- .newSingleThreadExecutor()
  - 这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它，它的特点是能确保依照任务在队列中的顺序来串行执行
- .newScheduledThreadPool(int corePoolSize)
  - 创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer

## 10.线程池都有哪些状态？

- 线程池有五种状态，Running、ShutDown、Stop、Tidying、Terminated。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJT1B3UFRLSkpYYW9ydzFGSk1OUkthT2libXBwZG04R0lpYjAwUUNneWliclZoRmNVNHR2akFCb1lCVUtpYlZFZlE5VXZBdlQwbGliV0E5TFdnLzY0MA?x-oss-process=image/format,png)

## 11.线程池中submit()和execute()方法有什么区别？

- 接受参数不一样
- submit有返回值，而execute没有
- submit方便Exception处理

## 12.在java程序中怎么保证多线程的运行安全？

- 线程安全在这个三个方面体现：
  - 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作 ，atomic，synchronized
  - 可见性：一个线程对主内存的修改可以及时地被其它线程看到，synchronize，volatile
  - 有序性：一个线程观察其它线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，happens-before原则

## 13.多线程锁的升级原理是什么？

- 在java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁，重量级锁，这几个状态会随着竞争情况逐渐升级，锁可以升级但不能降级
- ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJT1B3UFRLSkpYYW9ydzFGSk1OUkthTzFwYVdpYThyR2RoTkdEeW1KNVdpYk5ZOHBFaWJsNm0yMUZnNUpoNlhZUURIa0hzVHZlUVVmZXVDdy82NDA?x-oss-process=image/format,png)

## 14.什么是死锁？

- 死锁是指两个或两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称。

## 15.怎么防止死锁？

- 死锁的四个条件

  - 互斥条件：进程对所分配到资源不允许其它进程进行访问，若其它进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
  - 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其它进程占有，此事请求阻塞，但又对自己获得的资源保持不放

  - 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
  - 环路等待条件：是指进程发生死锁后，若干进程之前形成了一种头尾相接的循环等待资源关系

- 这四个条件就是死锁的必要条件，只要系统发生死锁这些条件必然成立，只要上述条件之一不满住就不会发生死锁，理解了死锁的原因尤其是产生死锁的四个必要条件，就可以最大可能的避免、预防和接触死锁。所以在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源，此外也要防止进程在处于等待状态的情况下占用资源，因为，对资源的分配要给予合理的规划

## 16.ThreadLocal是什么，有哪些使用场景？

- 线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程之间共享，java提供ThreadLocal类来支持线程局部变量，是一种实现实现安全的方式，但是在管理环境下(web服务器)使用线程局部变量的时候要特别小心，在这种情况下，工作线程和生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java应用就存在内存泄露的风险

## 17.说一下synchronized底层实现原理

- synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入临界区，同时它还可以保存共享变量的内存可见性
- java中每一个对象都可以作为锁，这是synchronized实现同步的基础：
  - 普通同步方法，锁是当前实例对象
  - 静态同步方法，锁是当前类的class对象
  - 同步方法块，锁是括号里面的对象

## 18.synchronized 和 Lock 有什么区别？

- 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
- synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
- synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
- 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结了；
- synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；
- **Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。**

## 19.synchronized和ReentrantLock区别是什么？

synchronized是和if，while，for一样的关键字，而ReentrantLock是一个类，这是本质上的区别，ReentrantLock提供了更加灵活的特性可以被继承、可以有方法各种类的变量

- 可以获取锁的等待时间来进行设置，就避免了死锁
- 可以获取锁的信息
- 可以灵活的实现多路通知
- 另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。





# 五、Jave Web

## 1.jsp和servle有什么区别？

- jsp编译后就变成了Servlet
  - jsp本质就是Servlet，jvm只能识别java类，不能识别jsp代码，web容器将jsp代码编译成jvm能够识别的java类
- jsp擅长表现页面显示，Servlet擅长于逻辑控制
- Servlet中没有内置对象，jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到
- jsp是Servlet的一种简化，使用jsp只需要完成程序员需要输出给客户端的内容，jsp中的java脚本如何镶嵌到一个类中，由jsp容器完成，而Servlet则是一个完整的java类，这个类的Service方法用于生成客户端的响应

## 2.jsp 有哪些内置对象？作用分别是什么？

- JSP有9个内置对象：

- request：封装客户端的请求，其中包含来自GET或POST请求的参数；
- response：封装服务器对客户端的响应；
- pageContext：通过该对象可以获取其他对象；
- session：封装用户会话的对象；
- application：封装服务器运行环境的对象；
- out：输出服务器响应的输出流对象；
- config：Web应用的配置对象；
- page：JSP页面本身（相当于Java程序中的this）；
- exception：封装页面抛出异常的对象

## 3.说一下 session 的工作原理？

- 其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。

## 4. 如何避免 sql 注入？

1. PreparedStatement（简单又有效的方法）

2. 使用正则表达式过滤传入的参数

3. 字符串过滤

4. JSP中调用该函数检查是否包函非法字符

5. JSP页面判断代码

   

# 六、异常

## 1.throw和throws的区别

- throws是用来生命一个方法可能抛出所有异常的信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就给谁处理。而throw则是指抛出一个具体的异常类型

## 2.final、finally、finalize有什么区别？

- final可以修饰类、变量、方法，修饰类不能被继承、修饰方法不能被重写、修饰变量不能被重新赋值
- finally一般作用在try-catch代码块中，在处理异常的时候，通让我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常、该代码块都会执行，一般用来存放一些关闭资源的代码
- finalize是一个方法，属于Object类的一个方法，而Object类所有类的父类，该方法一般有垃圾回收器调用，当我们调用system的gc方法的时候，由垃圾回收器调用finalize()回收垃圾

## 3.try-catch-finally 中哪个部分可以省略?

- catch 可以省略

### 4. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？**

- 会执行，在 return 前执行。



# 七、Spring

## 1.为什么要使用Srping

- 简介
  - 目的：解决企业应用开发的复杂性
  - 功能：使用基本的JaveBean代替EJB，并提供了更多的企业应用功能
- 轻量
  - 从大小与开销两方面而言Spring都是轻量的，完整的Spring框架可以在一个大小只有1MB多的jar文件里发布，并且Spring所需的处理开销也微不足道。此外，Spring是非侵入的:典型的，Spring应用中的对象不依赖与Spring的特定类
- 控制反转IOC
  - 控制： 对于成员变量赋值的控制权
    反转控制：把对于成员变量赋值的控制权，从代码中反转(转移)到Spring工厂和配置文件中完成
- 依赖注入DI：
  - 当一个类需要另一个类时，就意味着依赖，一旦出现依赖，就可以把另一个类作为本类的成员变量，最终通过Spring配置文件进行注入(赋值)。

## 2.解释一下什么是AOP

面向切面编程是一种设计思想。主要由连接点，切点，增强、切面组成。AOP依托于代理模式进行实现，所以AOP拥有代理模式的特性。可以在不改变原有类的情况下，能动态的添加某些功能。所以说比较适合来实现，打印请求日志，权限校验，等功能。针对不同的场景，AOP可以选择使用JDK动态代理或CGLIB代理来实现。由于CGLIB创建出来的代理类运行速度快于JDK动态代理，但是创建的过程太慢，所以可以将其创建出来的代理类交由IOC容器进行管理，免去了重复创建代理不必要的性能开销，来提高运行速度。

- 连接点：就是可以进行切入的地方，一个类中的所有方法都可以被视为连接点
- 切入点：就是切点表达式匹配的连接点，也就是可以在这个方法上进行通知的点
- 通知：真正要执行的代码，就是说你要给切入点织入哪些代码，通知分为前置通知，后置通知，异常通知，返回通知，环绕通知
- 切面：通知与切入点的组合，
- 织入：把切面应用到目标对象并生成代理对象的过程
- 面相切面编程，原理就是本来是在执行方法前创建一个动态代理，很麻烦，但是引入aop以后，就不需要手动的创建动态代理，你加入注解或者配置以后，也能在方法执行前创建一个动态代理，动态代理的目的就是在方法执行前后可以加入一些操作管理方法的结果，没什么原理，就是本来手动创建动态代理，变成了spring帮你创建，其实还是内部还是动态代理对象

## 3.Spring有哪些主要模块？

- Spring框架至今已集成了20多个模块，这些模块主要被分入下图所示的核心容器、数据访问、集成、Web、AOP、工具、消息、测试

## 4.Spring常用的有哪些注入？

- 通过set注入
- 构造方法注入
- 基于注解的注入

## 5.Spring中的bean是安全的吗？

-  Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。

## 6.Spring支持几种bean的作用？

- 当通过Spring容器创建一个Bean实例时，不进可以玩Bean实例的实例化，还可以为Bean指定特定的作用域，Spring支持一下五种作用域：

  - singleton ：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。
  - prototpe：为每一个bean请求提供一个实例
  - request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。

  - session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。
  - globalsession：局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。

## 7.Spring自动装配Bean有哪些方式？

- Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起
- Spring中Bean装配有两种方式：
  - 隐式的bean装配有两种方式
  - 在java代码或者XML中进行显示配置

## 8.Spring事务实现方式有哪些？

- 1.编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、
- commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。
- 2.基于 TransactionProxyFactoryBean 的声明式事务管理
- 3.基于 @Transactional 的声明式事务管理
- 4.基于 Aspectj AOP 配置事务

## 9.说一下Spring的事务隔离

- 脏读：一个事务读到另一个事务未提交的更新数据
- 幻读：列如第一事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行数据”。那么以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好像发生了幻觉一样
- 不可重复度：比如说同一个事务中先后执行两条一波一样的查询语句，期间再次事务中没有执行ddl语句，但先后得到的结果不一致就是不可重复读

## 10.BeanFactory和ApplicationContext有什么区别？

- BeanFactory和ApplicationContest是Spring的两大核心接口，都已当做Spring的容器，其中ApplicationContext是BeanFactory的子接口
- BeanFactor采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean加载实例化
- ApplicationContext，它是在容器启动时，一次性创建了所有的Bean

## 11.请解释下Spring Bean的生命周期？

- 实例化Bean->设置对象属性(依赖注入)->处理Aware接口->beanPostProcessor->InitializingBean->DisposableBean->destroy-method

## 12.Spring框架的单列Beans是线程安全的吗？

- 在一般情况下，只有无状态的Bean才可以多线程环境下共享，在Spring，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程处理
- ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题，同步机制采用了“空间换时间”方式

- ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突，因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装到ThreadLocal

# 八、SpringMVC

## 1.什么是SpingMVC

- SpringMVC是一个基于Java的实现了mvc设计模式的请求驱动类型的轻量级web框架，通过model，view，controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合

## 2.SpringMVC的流程

- 第一步:用户发起请求到前端控制器（DispatcherServlet）

  第二步：前端控制器请求处理器映射器（HandlerMappering）去查找处理器（Handle）：通过xml配置或者注解进行查找

  第三步：找到以后处理器映射器（HandlerMappering）像前端控制器返回执行链（HandlerExecutionChain）

  第四步：前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler）

  第五步：处理器适配器去执行Handler

  第六步：Handler执行完给处理器适配器返回ModelAndView

  第七步：处理器适配器向前端控制器返回ModelAndView

  第八步：前端控制器请求视图解析器（ViewResolver）去进行视图解析

  第九步：视图解析器像前端控制器返回View

  第十步：前端控制器对视图进行渲染

  第十一步：前端控制器向用户响应结果![img](https://img-blog.csdn.net/20180708224853769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  

  前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。

  处理器映射器（HandlerMapping）：根据URL去查找处理器

  处理器（Handler）：（需要程序员去写代码处理逻辑的）

  处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用）

  视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面



## 3.Spring的优点

- 可以支持各种视图技术，而不仅仅局限于JSP
- 与Spring框架集成(如IOC容器，AOP等)
- 清晰的角色分配：前端控制器，请求到处理器映射，处理器适配器，视图解析器
- 支持各种请求资源的映射策略

## 4.SpringMVC主要组件？

- 前端控制器 DispatcherServlet
  - 接受请求、响应结果，相当于转发器，有了dispatcherServlet，就减少了其它组件的耦合度
- 处理器映射器HandlerMapping
  - 根据请求的URL来查找Handler
- 处理器适配器HandlerAdapter
  - 在编写Handler时候需要按照HandlerAdapter要求的规范的去编写，这样适配器
    HandlerAdpter才可以正确的去执行Handler。
- 处理器Handler(需要程序员开发)
- 视图解析器ViewResolver
  - 作用：进行视图的解析，根据视图逻辑名解析成真正的视图(view)
- 视图View(需要程序开发jsp)
  - View是一个借口，它的实现类支持不同的视图类型(jsp,freemarker,pdf等等)



## 5.SpingMVC怎么和AJAX相互调用的？

- 通过Javkson框架就可以把java里面的对象直接转化成js可以识别的json对象具体步骤如下
  - 加入javkson.jar
  - 在配置文件中配置json的映射
  - 在接受ajax方法里面可以直接返回object，list等，但方法前面要加上@ResponseBody注解

## 6.SpingMVC的异常处理？

- 可以将异常抛给Sping框架，又Sping框架来处理，我们只需要简单的异常处理器，在异常处理器添视图页面即可

## 7.SpringMVC的控制器是不是单例模式，如果是有什么问题解决

- 是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。



# 九、Mybatis

## 1.什么是Mybatis？

- 它内部封装了jdbc ，开发只需要关注sql语句本身，不需要花费精力加载驱动，创建连接等繁杂过程

- ·通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。

## 2.Mybatis的优点

- 基于sql的语句编程，灵活，接触sql在XML里面与程序代码的耦合，便于管理
- 与jdbc减少了%50以上代码量，消除了JDBC大量冗余的代码，不需要手动开关连接
- 很好的与各种数据兼容
- 能够与Sping很好的集成
- 提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。

## 3.Mybatis的缺点

- SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写sql语句要有技术要求
- SQL语句依赖数据库，不能随意更换数据库

## 4.#{}和$()有什么区别？

- #{}是站位符，有效防止sql注入提高系统安全
- #{}是预编译处理，${}是字符串替换。
- Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；
- ${}是字符串替换

## 5.当实体类中的属性名和表中的字段名不一样 ，怎么办 ？

-  通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。

## 6.通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？

- DAO接口即为Mapper.xml文件，通过namespace映射。
- Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略



# 十、注解

## 1.Spring注解

@Component： 标准一个SpringBean类

@Repository： 标注一个DAO组件类

@Service： 		标注一个业务逻辑组件类

@Controller：	标注一个控制器组件类

装配Bean时常用注解：

@Autowired	@PostConstruct	@Resource

## 2.SpringMVC

@Controiller:表名该类是与前端作为交互的控制层组件

@RequestMapping：用于处理请求的url映射的注解，可用于类或方法上，用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径

@RequestBody：注解实现接受http请求的json数据，将json转换为java对象

@ResponseBody：注解实现将conreoller方法返回对象转换为json对象响应给客户

## 3.mybatis

结果映射	@Insert	@select	@SelectKe	@Updat	@Delete

结果映射	@Result	@Results	@ResultMap

关系映射	@one	@many



# 第一、面试必问

## 1.集合

### 1.1 ArrayList与LinkedList的实现和区别

1.ArrayList的中间插入或者删除一个元素意味着列表剩余的元素都会被移除，而在LinkedList的中间插入或删除一个元素开销是固定的

2.ArrayList的空间浪费主要体现在list列表结尾预留一定的容量空间，而linkedList的空间花费则体现现在它的每一个元素都需要消耗相当的空间。

3.LinkedList不支持高效的随机访问

4.ArrayList的查询效率比较高，增删动作效率比较差，适用于频繁的查询，增删动作较小的元素集合

5.LinkedList的查询效率比较低，但是增删效率很高，适用于增删动作的比较频繁，查询次数较少的集合

### 1.2 map数据结构、hash冲突如何解决、链表红黑树、扩容时机

#### 1.map数据结构

- 将键映射到值对象，一个映射不能包含重复的键，每个键最多只能映射一个值
- map集合储存元素是成对出现的，map集合的键是唯一的，值是可以重复

#### 2.HashMap

- 使用哈希算法对键去重，效率高，但是无序
- HashMap是map的接口主要实现类
- 底层采用了数组+链表 jdk8 加入了红黑树
- 加载因子为0.75

#### 3.Hash冲突如何解决

- 链表法就是讲相同的hash值的对象组织成一个链表放在hash值对应的槽位
- 开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可用槽位

#### 4.扩容时机

- 什么时候扩容？
  - 当向容器添加元素的时候，会判断当前的元素个数，如果大于等于阈(yu)值-即当前数组的长度乘以加载因子的值的时候，就要自动扩容
- 扩容(resize)就是重新计算容量，向hashmap对象里不停的添加元素，而HashMap对象内部的数组无法承载更多的元素，对象就需要扩大数组的长度，以便装更多的元素，当然java无法自动扩容，方法是使用一个新的数组代理已有容量的小数组
  - 初始化长度为16
  - 负载因子0.75
  - 阈值是12
  - 链表长度大于8转换红黑树
  - 红黑树长度小于6转换链表数据结构
  - 扩容是两倍

### 1.3LinkedHashMap基本原理，那两种有序、如何用它实现LRU

- LinkedHashMap是HashMap的子类，但是内部还有一个双向链表维护键值的顺序，每个键值对即位于哈希表中，也位于双向链表中。LinkedHashMap支持两种顺序，插入顺序和访问顺序
- 两种有序
  - 按插入顺序排（当 accessOrder = false）
  - 按最近获取的数据倒叙当 accessOrder = true）

### 1.4TreeMap 了解数据结构、了解key对象为什么必须要实现Compare接口、如何用它实现一致性哈希Set，Set基本上都是由对应的map实现

- TreeMap是基于红黑树，该集合特点是可排序
- 省略 -  - - -- - 

## 2.基础常问问题

### 1 hashmap如和解决hash冲突，为什么hashmap中的链表需要转成红黑树？

- 链表法就是讲相同的hash值的对象组织成一个链表放在hash值对应的槽位
- 开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可用槽位
- 为什么hashmap中的链表需要转成红黑树？
  - 因为长度为8的时候，平均查找长度为3，如果使用链表，是会查找很慢，这才有必要转换为树，还有就是选择6和8中间有个差值7可以有效防止链表和树的频繁转换，假设一下如果hashmap不停的在8左右插入删除就会频繁生成树转链表，链表转树，效率就会变得很低

### 2 hashmap什么时候触发扩容？

- 当HashMap中元素总个数达到阈值时就会扩容
- 存放新值的时候当前存放数据发生hash碰撞

扩容机制

- 如果要扩容，调用resize（）；

### 3 jdk1.8之前并发操作hashmap时为什么会有死循环的问题？

- hashmap线程是不安全的，hashmap在执行并发put操作发生扩容，可能会导致节点丢失，产生环形链表情况
  - 节点丢失会导致数据不准确
  - 生成环形链表会导致死循环
- 在jdk1.8前，由于扩容使用头插法会导致环形列表导致死循环，在jdk1.8之后改用尾插法可以避免这个问题，但是依然避免不了节点丢失的问题
- HashMap的设计初衷就不是在并发情况下使用，如果有并发的场景，推荐使用ConcurrentHashMap

### 4 hashmap扩容时每个entry需要在计算一次hash吗？

- 不需要，在扩充HashMap的时候不需要像jdk.17的实现那样重新计算hash，通过使用e.hash&oldCap来计算高位和低位hash值，来把原来一个槽位上面的链表拆分成两个链表即可。

### 5 hashmap数组长度为什么要保证是2的幂？

HashMap的长度为2的幂次方的原因是为了减少Hash碰撞，尽量使Hash算法的结果均匀分布。

### 6 如何用LinkedHashMap实现LRU？

- 如果我们想要达到LRU的效果，在构造LinkedHashMap时，accessOrder就应该赋值true。

- removeEldestEntry：LinkedHashMap中一个重要的方法，默认返回false，表示是否删除最旧的元素，如果要实现LUR，就要override该方法，告诉LinkedHashMap什么情况下删除旧元素，譬如，当整个LinkedHashMap的size达到设定的阈值，需要删除旧元素。

### 7 如何用TreeMap实现一致性hash？

 1.数据结构：我们可以使用 TreeMap 数据结构，优点是该数据结构是有序的，无需再排序，而且该数据结构中有个函数叫 **tailMap**，作用是获取比指定的 key 大的数据集合；
 2.hash 算法：此处我们使用 **FNV1_32_HASH** 算法，该算法证实下来散列分布比较均匀，hash 碰撞尚且 ok；
 3.虚拟节点：我们暂且设置每个节点锁裂变的虚拟节点数量为10。

### 8.HashMap的源码实现原理，JDK8中对HashMap做了什么优化？

1.在jdk1.6,1.7中，HashMap采用数组+链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值一次查找的效率较低，而jdk1.8中，HashMap采用位桶+链表+红黑树实现，当链表阈值长度为8时，将链表转换红黑树，大大减少了查找时间

2.首先有一个每个元素都是链表（可能表述不准确）的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。

### 9.HashMap扩容是怎么样扩容的，为什么都是2的N次幂的大小？

因为2的幂-1都是11111结尾的，所以碰撞几率小。

### 10.HashMap，Hashtable，ConcurrentHashMap的区别？

#### HashMap：

- 底层数组+链表。线程不安全，运行效率要比Hashtable高，支持null值。扩容2倍，负载因子0.75

#### HashTable:

- 底层数组+链表，效率低，线程安全，不支持空值。初始值是11 扩容为原来的2倍+1，负载因子是0.75

#### ConcurrentHashMap:

- 数组+链表 线程安全，效率提升N倍，默认提升16倍

### 11.极高并发下的HashTable和ConcurrentHashMap哪个性能更好，为什么，如何实现的？

- ConcurrentHashMap
- Hashtable的synchronize是针对整张Hash表的，即每次占用了大量内存造成浪费而且也造成了时间的浪费
- ConcurrentHashmap的实现方式是段锁，ConcurrentHashMap将hash表分为16个桶（默认值），get，put，remove等常用操作只锁当前需要用到的段落，原来只能一个线程进入，现在却能同时16个写线程进入，并发性提升显而易见

### 12.HashMap在高并发下如果没有处理线程安全会有那些安全隐患，具体表现是什么？

- 多线程put时可能会导致get无限循环，具体表现为CPU使用率100%。
- 在向HashMap put元素，会检查HashMap的容量足够多，如果不足，则会新建一个比原来容量大两倍的Hash表，然后把数组从老的Hash表中迁移到新的Hash表中，迁移的过程就是一个rehash()的过程，多个线程同时操作就有可能会形成循环链表，所以在使用get()时，就会出现Infinite Loop的情况

### 13.Object类中的方法

getclass，hashcode，clone,wait,finalize,equals,toString

### 14.java四种修饰符的限制范围

private	只能访问类内

default	只能访问一个包里面的

protected 访问子类

public		都能访问

### 15.接口和抽象类的区别，注意JDK8的接口可以有实现

- 接口不能实例化接口定义方法和属性，属性必须赋值初始化，定义的属性不能实现只能交给由实现接口的类来实现该方法，接口在1.8可以定义静态方法并且实现，接口可以多个实现
  - 接口在1.8有关键字static和default
- 抽象不能实例化抽象要被子类继承，抽象类可以做方法声明也可以实现，抽象类也可以有方法和属性，但类只能单根继承

### 16.动态代理的两种方式，以及区别

- 在Java中`java.lang.reflect`包下提供了一个Proxy类和一个`InvocationHandler`接口，通过使用这个类和接口就可以生成动态代理对象。

- JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib

### 17.Java序列化的方式

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object obj)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。

### 18.传值和传引用的区别，有没有传值引用？

1. 在java中所有的参数都是传值的，引用符号&的传递是C++中才有的；

2. 在java传参中，基本类型(byte--short--int--long--float--double--boolean--char)的变量总是按值传递；

3. 对于对象来说，不是将对象本身传递给方法，而是将对象的的引用或者说对象的首地址传递给方法，引用本身是按值传递的；

4. 对于String、Integer、Long，数组等，这些都相当于对象，因此传参时相当于是传引用；

### 19.一个ArrayList在循环过程中删除，会不会出现问题？

- 不能直接在循环中进行删除，需要加一些条件
- 先删除，然后遍历时后一个字符并没有遍历到，所以无法删除。

### 20.@transactional注解在什么情况下会失效，为什么？

- service类标签(一般不建议在接口上)上添加@Transactional，可以将整个类纳入spring事务管理，在每个业务方法执行时都会开启一个事务，不过这些事务采用相同的管理方式。

- @Transactional 注解只能应用到 public 可见度的方法上。 如果应用在protected、private或者 package可见度的方法上，也不会报错，不过事务设置不会起作用。

- 默认情况下，Spring会对unchecked异常进行事务回滚；如果是checked异常则不回滚。 
  辣么什么是checked异常，什么是unchecked异常

### 21.JDK8新版本变化

1. 速度更快 – **红黑树**
2. 代码更少 – **Lambda**
3. 强大的Stream API – **Stream**
4. 便于并行 – **Parallel**
5. 最大化减少空指针异常 – **Optional**



## 3.Sping框架

### 1bean的生命周期

1.实例化Instantiation

2.属性赋值Populate

3.初始化Initialization

4.销毁Destruction

实例化 → 属性赋值 → 初始化 → 销毁

### 2 循环依赖问题

- 如何理解依赖 在spring中
  - 构造器循环依赖
  - set循环依赖
  - field属性注入循环依赖

- 解决方案：
  - Spring容器提前暴露刚完成构造器注入但未完成其他步骤(如seter注入)的bean来完成的。而且只能解决单列作用域的bean循环依赖。通过提前暴露一个单例工厂方法，从而使其他bean能引用该bean。

### 3 AOP的实现

- AOP面向切面编程可以说是OOP面向对象编程的补充和完善。OOP引入了封装、继承、多态等概念来建立一种对象层次架构，用以模拟公共行为的一个集合。当我们需要分散的对象引入公共行为的时候，OOP显得无能为力。也就说OOP允许你定义从上到下的关系，但并不适合从左到右的关系，列如日志功能。日志代码往往水平得散步在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其它类型的代码，如安全，异常处理和透明的持续性也是如何。这种散布在各处的无关代码被称为横切代码。在OOP设计中，它导致了大量代码重复而不利于各个模块的重用。
- 而AOP技术则恰恰相反，它利用一种为"切面"的技术，剖解开封装的对象内部，并将那些影响多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”,即方面。所谓方面，简单的说就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复的代码，降低模块的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说对象是一个空心的圆柱体，其中封装的是对象和属性的行为，那么面向编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得内部的消息，而剖开的切开，也就是所谓的方面了。然后它又以巧夺天空的妙手将这些剖开的切面复原，不留痕迹
- 使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分为横切关注点。横切关注点是一个特点。他们经常发生在核心关注点的多处，而各处都基本相似。如权限认证，日志，事务处理。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。AOP的核心思想就是“将应用程序中的商业逻辑同对提供支持的通用服务进行分离"
- 实现AOP的技术，主要分为两大类：一种是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有代码行为的执行，二是采用静态方式，引入特定的语法创建方面，从而使得编译器可以再编译期间植入有关“方面的代码”

### 4 Spring事务传播

- propagation用来设置事务的传播行为

  - 事务的传播行为：一个方法运行在了一个开启事务的方法中，当前方法使用依附的方法事务还是使用自身的事务

  -  Propagation.REQUIRED默认值 使用其依附的别人方法的事务

    ​       Propagation.REQUIRES_NEW 将原来的事务挂起 开启一个新的事务（即执行自身的事务）

    使用方法  在需要使用事务的方法上加注解  @Transactional 什么都不加默认为Propagation.REQUIRED

    若想开启新事务执行自己的事务则可以在方法上加@Transactional(propagation=Propagation.REQUIRES_NEW)

    

- isolation用来设置事务的隔离级别

     Oracle支持的事务隔离级别为  （默认读已提交read committed  串行化 serializable 

  -   Mysql支持所有的事务隔离级别 读未提交 read uncommitted  
  - ​                           读已提交 read commited
  - ​                           (默认)可重复读 repeatable read
  - ​                           串行化 serializable      

## 4.Spring常见问法

### 1. java动态代理和cglib动态代理的区别？

JKD动态代理特点：

- 特点
  - Interface：对于JDK Proxy，业务类是需要一个Interface的，这是一个缺陷
  - Proxy：Proxy类是动态产生的，这个类在调用Proxy.newProxyInstance()方法之后，产生一个Proxy类的实力。实际上，这个Proxy类也是存在的，不仅仅是类的实例，这个Proxy类可以保存在硬盘上
  - Method：对于业务委托类的每个方法，现在Proxy类里面都不用静态显示出来
  - InvocationHandler：这个类在业务委托类执行时，会调用invoke方法。invoke方法在执行想要的代理操作可以实现对业务方法的再包装
- 总结：
  - JDK动态代理类实现了InvocationHandler接口，重写的invoke方法。
  - JDK动态代理的基础是反射机制

cglib动态搭理：

- 特点
  - 原理是对指定目标生成一个子类，并覆盖其中方法实现增加，但因为采用的是继承，所以不能对final修饰的类进行代理
  - **注意**：JDK的动态代理只可以去为接口去完成操作，而cglib它可以为没有实现接口的类去做代理，也可以为实现接口的类去做代理。



### 2. spring中的bean生命周期是怎么样的？

1.实例化Instantiation

2.属性赋值Populate

3.初始化Initialization

4.销毁Destruction

实例化 → 属性赋值 → 初始化 → 销毁



### 3. 属性注入和构造器注入那种会有循环依赖的问题?

- 问题描述：Bean A依赖B，Bean B依赖A，这种情况下即为循环依赖，如下：

     Bean A --> Bean B --> Bean A

   导致问题：当存在循环依赖时，Spring将无法决定先创建哪个bean，这种情况下，Spring将产生异常BeanCurrentlyInCreationException。

- 解决：

  - 消除循环依赖的方式是通过延迟加载，只需要在任意一个中使用@Lazy即可解决

  - 使用setter注入

    当依赖最终被使用时再进行注入是最佳的一种方式，同时这也是Spring最推荐的一种方式

## 5.多线程重点知识

### 1.Java实现多线程有哪些方式？

1.实现Runnbale接口，并实现接口的run()方法

2.继承Thread，重写run()方法

3.实现Callable接口，重写call()方法

### 2.Callable和Future的了解？

- Callable产生结果，可以获取线程运行的返回值 Future可以拿到结果知道Callable的返回执行结果，并且提供了get（）方法

### 3.线程池的参数有哪些？在线程池创建一个线程个过程？

1.newSingleThreadExecutror

- 单个线程的线程池，即线程池中每次只有一个线程工作，单线程串执行任务

2.newFixedThreadExecutor

- 固定数量的线程池，每提交一个任务就是一个线程，直到达到线程池的最大数量，然后后面进入等待队列直到前面的任务完成后才继续执行

3.newCatheThreadExecutor(推荐使用)

- 可缓存线程池，当线程池大小超过了处理任务所需的线程，那么就会回收部分空闲(一般是60秒无执行)的线程，当有任务来时，又只能的添加新线程来执行

4.newScheduleThreadExecutor

- 大小无限制的线程池，支持定时和周期性的执行线程

### 4.volatile关键字的作用及其原理？

- volatile关键字是一个轻量保持内存可见性 所有线程都能看到共享内存的最新状态,不保证原子性
  - 在讲volatile关键字之前，我需要先讲讲java的内存模型，我们的java的变量都存储在主内存当中，每当有一个线程需要读取内存中的变量的时候，java虚拟机会将主内存中的变量拷贝一份放入线程的工作内存中，多个线程之间并不可见，如果我们要保证可见性，就得使用volatile关键字，volatile可以保证变量的可见性，通过通知的方式让其他线程可见，但volatile并不保证变量的原子性，如果要保证变量的原子性，我们可以使用sync关键字或者atomic类，同时volatile可以禁止指令重排，因为编译器和cpu会对我们的代码进行优化，在一些数据没有依赖性的时候，我们的代码执行顺序可能不是我们想象的那样，在多线程情况下，可能会造成一些奇怪的错误，volatile实现指令重排的底层是使用了一个cpu指令叫内存屏障，通过内存屏障的前后指令会不进行指令重排，同时会强制刷新cpu缓存。

### 5.synchronized关键字的用法，优缺点？

- 修饰实例方法，作用相当于实例加锁，进入同步代码前要获得当前实例的锁
- 修饰静态方法，作用与当前类对象加锁，进入同步代码前要获得当前类对象的锁
- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

缺点就是慢

### 6.Lock接口有哪些实现类？

- ```
  ReadWriteLock
  ReentrantLock
  see Condition
  ```

- Lock 实现提供了比 synchronized 关键字 **更灵活、更广泛、粒度更细** 的锁操作，它能以更优雅的方式处理线程同步问题
  - **synchronized是Java的关键字，因此是Java的内置特性，是基于JVM层面实现的，其经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 两个字节码指令；而Lock是一个Java接口，是基于JDK层面实现的，通过这个接口可以实现同步访问；**
  -  **采用synchronized方式不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而 \Lock则必须要用户去手动释放锁 \\(发生异常时，不会自动释放锁)\*\*，\**如果没有主动释放锁，就有可能导致死锁现象。**

### 7.可重入锁的用处及其实现原来，复制的过程，读写锁，分段锁

- 重入锁ReentrantLock，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁还支持获取锁时的公平和非公平性选择

- ## 公平锁

  - 如果在绝对时间上，先对锁进行获取的请求一定 先被满足，那么这个锁是公平的，反之，是不公平的。

    公平的获取锁，也就是等待时间最 长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数， 能够控制锁是否是公平的。

- **读写锁**

  - 读写锁在同一时刻可以允许多个线程访问，但是在线程方式时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发相比一般的排他锁有了很大提升。
  - 读写锁的特性
    - 公平选择：支持非公平(默认)和公平的锁获取方式，吞吐量还是非公平由于公平
    - 重进入：该锁支持重进入，以读写线程为例：该线程在获取了读锁之后，能够再次获取读
    - 锁。而写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁。
    - 锁降级：遵循获取写锁、获取读锁在在释放写锁的次序，写锁能够降级为读锁

- 自旋锁
  - 首先是一种锁，与互斥锁相似，基本作用是用于线程（进程）之间的同步。与普通锁不同的是，一个线程A在获得普通锁后，如果再有线程B试图获取锁，那么这个线程B将会挂起（阻塞）；试想下，如果两个线程资源竞争不是特别激烈，而处理器阻塞一个线程引起的线程上下文的切换的代价高于等待资源的代价的时候（锁的已保持者保持锁时间比较短），那么线程B可以不放弃CPU时间片，而是在“原地”忙等，直到锁的持有者释放了该锁，这就是自旋锁的原理，可见自旋锁是一种非阻塞锁。
  - 缺点是会过多占据cpu时间和死锁



### 8.悲观锁，乐观锁，优缺点，CAS有什么缺陷？

- 1.乐观锁
  - 总是假设最好的情况，每次去读数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候判断一下在此期间有没有其他线程更新该数据，可以使用版本号机制实现CAS算法实现。乐观锁适用于多度的应用类型，这样可以提高高吞吐量，像数据库提供的类似于wtrite_condition机制，其实都是提供的乐观锁。 在Java中java.util.concurrent.atomic包下面的原子变量类就是基于CAS实现的乐观锁。
  - AtomicInteger是一个乐观锁
- 2.悲观锁
  
- 总是假设最坏的情况，每次去读取数据的时候都认为别人会修改，所以每次在读数据的时候都会上锁，这样别人想读取数据就会阻塞值到它获取锁。传统的关系数据库表里面就用到了很多悲观锁机制，比如行锁，表锁，读锁，写锁，都是在操作之前先上锁。java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现
  
- **CAS**

  - 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。

  

### 9.ABC三个线程如何保证顺序执行？

- 使用CountDownLatch
- 使用Atom原子类 AtomicInteger

### 10.线程的状态都有哪些？

- 分别是6个状态New，Runnable，Blocked，Waiting，timed_Waiting,Terminated



- New:线程对象创建之后、启动之前，就是这个状态



- Runnble:当调用start方法后呢，线程就会进入Runnable状态，表示，我这个线程可以被执行了，如果调度器给这个线程分配了CPU时间，那么这个线程就可以被执行.



- Blocked:这个状态，当线程要进入临界区的时候，会发生。比如说，前面有一个临界区的代码需要执行，那么线程就会进入这个状态，如果只有一个线程呢，那么也就只有它一个在进入临界区了，它就会进入临界区开始执行，随后转为Runnable状态。如果有多个线程到了临界区，那么都会进入Blocked状态，由调度器选一个来执行，如果这个线程执行完毕后，大家还是一同为Blocked状态，调度器再选一个来执行。



- Waiting:当你调用了wait，join方法后，就会进入这个状态。一旦进入到这个状态，CPU就不会管你了，直到有别的线程通过notify方法将它唤起，否则的话，就会一直在等待中。设计这个状态怎么用呢？我的理解是，线程A需要完成一些事情，但是这些事情必须要满足某些条件才能继续，因此，如果我写一个死循环在这里等待，就很优雅了（浪费CPU资源），这时就可以使用这个waiting状态，条件未满足前，我进入waiting状态，等条件满足了，别人来通知我，我在继续执行



- timed_Waiting:这个状态也是等待，但是是有一个计时器在里面，最常见的是使用Thread.sleep方法触发，触发后，线程就进入了Timed_waiting状态，随后会由计时器触发，再进入Runnable状态。



- Terminated:终结状态，当线程的所有代码都被执行完毕后，会进入到这个状态，这个就是字面意思了。

### 11.shell和wait的区别？

- sleep() 方法是线程类(Thred)的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间，因为sleep()是static静态方法，他不能改变对象的机制，当一个synchaonized块中调用了sleep()方法，线程虽然进入了休眠，但是对象的锁没有被释放，其它线程依然无法访问这个对象
- wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到了一个和该对象相关的等待池，同时释放对象的机锁，使得其它线程能够访问，可以通过notitfy，notifyAll方法来唤醒等待的线程

### 12.notify和notifyall的区别？

```java
notify唤醒一个等待的线程；notifyAll唤醒所有等待的线程。
```

### 13.ThreadLocal的了解，实现原理？

**1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。**

**2、线程间数据隔离**

**3、进行事务操作，用于存储线程事务信息。**

**4、数据库连接，Session会话管理。**



### 14.在java程序中怎么保证多线程的运行安全？

线程安全在这个三个方面体现：

- 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作 ，atomic，synchronized
- 可见性：一个线程对主内存的修改可以及时地被其它线程看到，synchronize，volatile
- 有序性：一个线程观察其它线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，happens-before原则

## 15.sleep()和wait()有什么区别吗？

- sleep() 方法是线程类(Thred)的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间，因为sleep()是static静态方法，他不能改变对象的机制，当一个synchaonized块中调用了sleep()方法，线程虽然进入了休眠，但是对象的锁没有被释放，其它线程依然无法访问这个对象
- wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到了一个和该对象相关的等待池，同时释放对象的机锁，使得其它线程能够访问，可以通过notitfy，notifyAll方法来唤醒等待的线程